<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Who's That Pok√©mon?</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            background: radial-gradient(circle at center, #1e3a8a 0%, #0f172a 100%);
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
            user-select: none;
        }

        /* Moving Background Pattern */
        .bg-pattern {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M30 30c0-5.5 4.5-10 10-10s10 4.5 10 10-4.5 10-10 10-10-4.5-10-10zm-5 0c0 8.3-6.7 15-15 15S-5 38.3-5 30s6.7-15 15-15 15 6.7 15 15zm40 0c0 8.3-6.7 15-15 15s-15-6.7-15-15 6.7-15 15-15 15 6.7 15 15z' fill='%23ffffff' fill-opacity='0.03' fill-rule='evenodd'/%3E%3C/svg%3E");
            z-index: -1;
            animation: bgScroll 60s linear infinite;
        }
        @keyframes bgScroll {
            from { background-position: 0 0; }
            to { background-position: 100% 100%; }
        }

        /* The core mechanic: Silhouette vs Revealed */
        .pokemon-sprite {
            transition: filter 0.5s ease-in-out, transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            image-rendering: pixelated;
            filter: brightness(0) contrast(100%);
            width: 250px;
            height: 250px;
            object-fit: contain;
        }

        .pokemon-sprite.revealed {
            filter: brightness(1) contrast(100%) drop-shadow(0 0 15px rgba(255,255,255,0.6));
            transform: scale(1.15) rotate(5deg);
        }

        /* 3D Button Styles */
        .quiz-btn {
            background-color: #3b82f6;
            border-bottom: 6px solid #1d4ed8;
            transition: all 0.1s;
        }

        .quiz-btn:active {
            transform: translateY(4px);
            border-bottom: 2px solid #1d4ed8;
        }

        .quiz-btn.correct {
            background-color: #22c55e;
            border-bottom-color: #15803d;
            animation: pulse-green 0.5s;
        }

        .quiz-btn.wrong {
            background-color: #ef4444;
            border-bottom-color: #b91c1c;
            opacity: 0.7;
        }

        /* Animations */
        @keyframes bounce-custom {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        .logo-bounce { animation: bounce-custom 3s infinite ease-in-out; }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-10px); }
            40% { transform: translateX(10px); }
            60% { transform: translateX(-10px); }
            80% { transform: translateX(10px); }
        }
        .shake-animation { animation: shake 0.4s ease-in-out; }

        .loader {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #facc15; /* Yellow top */
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        @keyframes pulse-green {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); box-shadow: 0 0 15px #22c55e; }
            100% { transform: scale(1); }
        }

        /* Flash Effect for correct answer */
        @keyframes flash {
            0% { background-color: rgba(255, 255, 255, 0.8); }
            100% { background-color: transparent; }
        }
        .flash-effect::after {
            content: '';
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 100;
            pointer-events: none;
            animation: flash 0.5s ease-out;
        }

        /* Confetti/Smoke Canvas */
        #particle-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 50;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center p-4">

    <div class="bg-pattern"></div>
    <canvas id="particle-canvas"></canvas>

    <!-- Header / Logo Area -->
    <div class="mb-6 relative w-full max-w-md text-center">
        <img src="https://upload.wikimedia.org/wikipedia/commons/9/98/International_Pok%C3%A9mon_logo.svg" 
             alt="Pokemon Logo" 
             class="w-64 mx-auto mb-4 drop-shadow-lg logo-bounce">
        
        <div class="flex justify-between items-center bg-blue-900/60 rounded-xl p-3 backdrop-blur-md border border-blue-400/30 shadow-lg">
            <div class="text-blue-200 text-sm w-1/3">Round: <span id="round-display" class="text-white font-bold text-lg">1</span>/20</div>
            <div class="text-blue-200 text-sm w-1/3">Streak: <span id="streak-display" class="text-white font-bold text-lg ml-1">0</span> üî•</div>
            <div class="text-blue-200 text-sm w-1/3">Best: <span id="high-score-display" class="text-yellow-400 font-bold text-lg ml-1">0</span> üëë</div>
        </div>
    </div>

    <!-- Game Container -->
    <div class="relative w-full max-w-lg" id="game-card">
        
        <!-- Loading Overlay -->
        <div id="loading-overlay" class="absolute inset-0 z-20 flex flex-col items-center justify-center bg-slate-900/90 rounded-2xl backdrop-blur-sm hidden">
            <div class="loader mb-3"></div>
            <p id="loading-text" class="text-yellow-200 font-bold animate-pulse">Scanning...</p>
        </div>

        <!-- Pokemon Image Area -->
        <div class="bg-blue-950/40 rounded-3xl p-8 mb-6 flex items-center justify-center border-2 border-white/10 shadow-2xl relative overflow-hidden min-h-[300px] group">
            <!-- Background glow effect -->
            <div class="absolute inset-0 bg-gradient-to-b from-transparent to-blue-900/40 pointer-events-none"></div>
            
            <img id="pokemon-image" src="" alt="Who's that Pokemon?" class="pokemon-sprite relative z-10 hidden">
            
            <!-- Result Text Overlay -->
            <div id="result-message" class="absolute bottom-6 left-0 right-0 text-center z-20 font-black text-2xl tracking-wide drop-shadow-[0_4px_4px_rgba(0,0,0,0.9)] opacity-0 transition-all duration-300 transform translate-y-4">
                <!-- Content injected by JS -->
            </div>
        </div>

        <!-- Options Grid -->
        <div id="options-grid" class="grid grid-cols-1 sm:grid-cols-2 gap-4 w-full">
            <!-- Buttons injected by JS -->
            <button class="quiz-btn h-14 rounded-xl font-bold text-lg shadow-lg opacity-50 cursor-wait">Loading...</button>
            <button class="quiz-btn h-14 rounded-xl font-bold text-lg shadow-lg opacity-50 cursor-wait">Loading...</button>
            <button class="quiz-btn h-14 rounded-xl font-bold text-lg shadow-lg opacity-50 cursor-wait">Loading...</button>
            <button class="quiz-btn h-14 rounded-xl font-bold text-lg shadow-lg opacity-50 cursor-wait">Loading...</button>
        </div>
    </div>
    
    <!-- Game Over Modal -->
    <div id="game-over-modal" class="hidden fixed inset-0 z-50 bg-slate-900/95 flex flex-col items-center justify-center text-center p-6 backdrop-blur-lg">
        <h2 class="text-4xl font-black text-yellow-400 mb-2 drop-shadow-[0_4px_0_rgba(0,0,0,0.5)]">Game Over!</h2>
        <p class="text-blue-200 mb-8">Here is your trainer report</p>
        
        <div class="bg-blue-900/50 p-8 rounded-3xl border border-blue-400/30 w-full max-w-sm shadow-2xl">
            <div class="flex justify-between mb-4 text-xl border-b border-white/10 pb-4">
                <span>Correct:</span> <span class="text-green-400 font-bold text-2xl" id="final-correct">0</span>
            </div>
            <div class="flex justify-between mb-4 text-xl border-b border-white/10 pb-4">
                <span>Wrong:</span> <span class="text-red-400 font-bold text-2xl" id="final-wrong">0</span>
            </div>
            <div class="flex justify-between text-xl">
                 <span>Accuracy:</span> <span class="text-yellow-400 font-bold text-2xl" id="final-accuracy">0%</span>
            </div>
        </div>
        
        <button onclick="resetGame()" class="mt-8 px-10 py-4 bg-yellow-500 hover:bg-yellow-400 text-yellow-900 rounded-2xl font-black text-xl shadow-[0_6px_0_rgb(161,98,7)] active:shadow-none active:translate-y-2 transition-all">
            Play Again
        </button>
    </div>

    <div class="mt-8 text-blue-400/60 text-xs text-center font-bold tracking-wider uppercase">
        Gotta guess them all ‚Ä¢ Thankyou For Playing
    </div>

    <script>
        // --- SAFE LOCAL STORAGE UTILS ---
        const safeStorage = {
            get: (key, fallback) => {
                try {
                    const val = localStorage.getItem(key);
                    return val ? parseInt(val, 10) : fallback;
                } catch (e) {
                    console.warn('Storage blocked:', e);
                    return fallback;
                }
            },
            set: (key, val) => {
                try {
                    localStorage.setItem(key, val);
                } catch (e) {
                    // ignore write errors
                }
            }
        };

        // Game State
        const state = {
            currentPokemon: null,
            options: [],
            isRevealed: false,
            streak: 0,
            highScore: safeStorage.get('pokemonHighScore', 0),
            isLoading: false,
            // Stats tracking
            roundsPlayed: 0,
            maxRounds: 20,
            correctCount: 0,
            wrongCount: 0
        };

        // Funny Phrases
        const phrases = {
            correct: [
                "Super Effective! üí•", "Critical Hit! üéØ", "Gotcha! üì¶", 
                "You're a Master! üèÜ", "Easy peasy! üòé", "Nice throw! üéæ",
                "It's evolving! ‚ú®", "Pokedex updated! üì±"
            ],
            wrong: [
                "It hurt itself in confusion! üòµ", "Team Rocket stole it! üöÄ", 
                "Are you a Magikarp? üêü", "Not very effective... üìâ", 
                "Professor Oak sighs... üìù", "Close, but no Berry! üçí",
                "Wild Pokemon fled! üí®", "Try using a Master Ball? üü£"
            ]
        };

        // DOM Elements
        const elImage = document.getElementById('pokemon-image');
        const elOptions = document.getElementById('options-grid');
        const elStreak = document.getElementById('streak-display');
        const elHighScore = document.getElementById('high-score-display');
        const elRound = document.getElementById('round-display');
        const elLoader = document.getElementById('loading-overlay');
        const elLoadingText = document.getElementById('loading-text');
        const elResult = document.getElementById('result-message');
        const elGameCard = document.getElementById('game-card');
        const elBody = document.body;
        // Game Over Modal Elements
        const elModal = document.getElementById('game-over-modal');
        const elFinalCorrect = document.getElementById('final-correct');
        const elFinalWrong = document.getElementById('final-wrong');
        const elFinalAccuracy = document.getElementById('final-accuracy');

        // Init
        updateScoreUI(); 
        startRound();

        async function startRound() {
            if (state.isLoading) return;
            // Update Round Display (using +1 because roundsPlayed is 0-indexed logic until completed)
            // But we want to show "Round 1/20", "Round 20/20". 
            // If we just finished round 20, we shouldn't be here (game over logic handles that).
            elRound.textContent = Math.min(state.roundsPlayed + 1, state.maxRounds);
            
            setLoading(true);
            resetUI();

            try {
                // 1. Pick a random ID for the correct answer (1 to 1010)
                const correctId = getRandomId();
                
                // 2. Pick 3 random wrong IDs (ensure no duplicates)
                const wrongIds = new Set();
                while(wrongIds.size < 3) {
                    const id = getRandomId();
                    if(id !== correctId) wrongIds.add(id);
                }

                // 3. Fetch data for all 4
                const idsToFetch = [correctId, ...wrongIds];
                const promises = idsToFetch.map(id => 
                    fetch(`https://pokeapi.co/api/v2/pokemon/${id}`).then(res => res.json())
                );
                
                const results = await Promise.all(promises);

                // 4. Process data
                const correctPokemon = results[0];
                const options = results.map(p => ({
                    name: formatName(p.name),
                    isCorrect: p.id === correctPokemon.id
                }));

                // 5. Shuffle options
                state.options = shuffleArray(options);
                state.currentPokemon = correctPokemon;

                // 6. Update UI
                const spriteUrl = correctPokemon.sprites.other['official-artwork'].front_default || correctPokemon.sprites.front_default;
                
                elImage.src = spriteUrl;
                elImage.onload = () => {
                    elImage.classList.remove('hidden');
                    setLoading(false);
                };
                
                renderOptions();

            } catch (error) {
                console.error("Failed to load Pokemon", error);
                setLoading(false); 
                setTimeout(startRound, 2000); // Retry logic
            }
        }

        function renderOptions() {
            elOptions.innerHTML = '';
            state.options.forEach((opt, index) => {
                const btn = document.createElement('button');
                btn.className = `quiz-btn text-white h-14 rounded-xl font-bold text-lg shadow-lg hover:brightness-110 active:scale-95 transition-transform duration-100 delay-[${index * 50}ms] animate-in fade-in slide-in-from-bottom-2`;
                btn.textContent = opt.name;
                btn.onclick = () => handleGuess(opt, btn);
                elOptions.appendChild(btn);
            });
        }

        function handleGuess(selectedOption, btnElement) {
            if (state.isRevealed) return; 
            state.isRevealed = true;
            state.roundsPlayed++;

            // Reveal Image
            elImage.classList.add('revealed');

            const allButtons = elOptions.querySelectorAll('button');

            if (selectedOption.isCorrect) {
                // Correct Logic
                state.correctCount++;
                btnElement.classList.add('correct');
                playSound('correct');
                
                fireConfetti();
                elBody.classList.add('flash-effect');
                setTimeout(() => elBody.classList.remove('flash-effect'), 500);
                
                state.streak++;
                if (state.streak > state.highScore) {
                    state.highScore = state.streak;
                    safeStorage.set('pokemonHighScore', state.highScore);
                }
                
                const randomPhrase = phrases.correct[Math.floor(Math.random() * phrases.correct.length)];
                showResult(`It's ${selectedOption.name}!<br><span class="text-sm text-yellow-300">${randomPhrase}</span>`, 'text-green-400');
            } else {
                // Wrong Logic
                state.wrongCount++;
                btnElement.classList.add('wrong');
                playSound('wrong');

                fireSmoke();
                elGameCard.classList.add('shake-animation');
                setTimeout(() => elGameCard.classList.remove('shake-animation'), 500);

                state.streak = 0;
                
                allButtons.forEach((btn, idx) => {
                    if (state.options[idx].isCorrect) {
                        btn.classList.add('correct');
                        btn.style.transform = 'scale(1.05)';
                    } else {
                        btn.style.opacity = '0.5';
                    }
                });
                
                const randomPhrase = phrases.wrong[Math.floor(Math.random() * phrases.wrong.length)];
                showResult(`Wrong! It was ${state.currentPokemon.name}!<br><span class="text-sm text-red-200">${randomPhrase}</span>`, 'text-red-400');
            }

            updateScoreUI();

            // Delay before next step
            setTimeout(() => {
                checkGameOver();
            }, 3000);
        }

        function checkGameOver() {
            if (state.roundsPlayed >= state.maxRounds) {
                showGameOver();
            } else {
                startRound();
            }
        }

        function showGameOver() {
            elFinalCorrect.textContent = state.correctCount;
            elFinalWrong.textContent = state.wrongCount;
            
            const accuracy = Math.round((state.correctCount / state.maxRounds) * 100);
            elFinalAccuracy.textContent = `${accuracy}%`;
            
            elModal.classList.remove('hidden');
            fireConfetti(); // Celebration confetti at the end too
        }

        function resetGame() {
            state.roundsPlayed = 0;
            state.correctCount = 0;
            state.wrongCount = 0;
            state.streak = 0;
            
            updateScoreUI();
            elModal.classList.add('hidden');
            startRound();
        }

        function resetUI() {
            state.isRevealed = false;
            elImage.classList.remove('revealed');
            elImage.classList.add('hidden');
            
            elResult.style.opacity = '0';
            elResult.style.transform = 'translateY(16px)';
        }

        function showResult(htmlContent, colorClass) {
            elResult.innerHTML = htmlContent;
            elResult.className = `absolute bottom-6 left-0 right-0 text-center z-20 font-black text-2xl drop-shadow-[0_3px_3px_rgba(0,0,0,0.8)] opacity-100 translate-y-0 transition-all duration-300 ${colorClass}`;
        }

        function updateScoreUI() {
            if(elStreak) elStreak.textContent = state.streak;
            if(elHighScore) elHighScore.textContent = state.highScore;
        }

        function setLoading(bool) {
            state.isLoading = bool;
            const loadingTexts = ["Waking up Snorlax...", "Polishing Pokeballs...", "Charging Pokedex...", "Walking in tall grass..."];
            if (bool) {
                elLoader.classList.remove('hidden');
                elLoadingText.textContent = loadingTexts[Math.floor(Math.random() * loadingTexts.length)];
            } else {
                elLoader.classList.add('hidden');
            }
        }

        // Utilities
        function getRandomId() {
            // Gen 1-9 (approx 1010 pokemon)
            return Math.floor(Math.random() * 1010) + 1;
        }

        function formatName(name) {
            return name.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function playSound(type) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return;
            
            const ctx = new AudioContext();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc.connect(gain);
            gain.connect(ctx.destination);
            
            if (type === 'correct') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(523.25, ctx.currentTime); 
                osc.frequency.setValueAtTime(659.25, ctx.currentTime + 0.1); 
                osc.frequency.setValueAtTime(783.99, ctx.currentTime + 0.2); 
                osc.frequency.exponentialRampToValueAtTime(1046.50, ctx.currentTime + 0.3); 
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.01, ctx.currentTime + 0.4);
                osc.start();
                osc.stop(ctx.currentTime + 0.5);
            } else {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                osc.start();
                osc.stop(ctx.currentTime + 0.3);
            }
        }

        // --- Particle Effects ---
        function getCanvas() {
            const canvas = document.getElementById('particle-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            return { canvas, ctx };
        }

        function fireConfetti() {
            const { canvas, ctx } = getCanvas();
            const particles = [];
            for(let i=0; i<150; i++) {
                particles.push({
                    x: canvas.width / 2, y: canvas.height / 2,
                    vx: (Math.random() - 0.5) * 25, vy: (Math.random() - 0.5) * 25,
                    color: `hsl(${Math.random() * 360}, 100%, 50%)`,
                    life: 1, gravity: 0.2 + Math.random() * 0.2
                });
            }
            animateParticles(particles, ctx, (p) => {
                p.x += p.vx; p.y += p.vy; p.vy += p.gravity; p.life -= 0.015;
            });
        }

        function fireSmoke() {
            const { canvas, ctx } = getCanvas();
            const particles = [];
            for(let i=0; i<60; i++) {
                particles.push({
                    x: canvas.width / 2 + (Math.random() - 0.5) * 100,
                    y: canvas.height / 2 + (Math.random() - 0.5) * 50,
                    vx: (Math.random() - 0.5) * 3, vy: -Math.random() * 3 - 1,
                    color: `rgba(${100 + Math.random()*100}, ${100 + Math.random()*100}, ${100 + Math.random()*100}, 0.5)`,
                    size: Math.random() * 20 + 10, life: 1, grow: Math.random() * 0.5 + 0.1
                });
            }
            animateParticles(particles, ctx, (p) => {
                p.x += p.vx; p.y += p.vy; p.size += p.grow; p.life -= 0.015;
            }, true);
        }

        function animateParticles(particles, ctx, updateFn, isSmoke = false) {
            function animate() {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                let active = false;
                particles.forEach(p => {
                    if(p.life > 0) {
                        active = true;
                        updateFn(p);
                        ctx.fillStyle = p.color;
                        ctx.globalAlpha = p.life;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, isSmoke ? p.size : 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                if(active) requestAnimationFrame(animate);
                else ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
            }
            animate();
        }
    </script>
</body>
</html>